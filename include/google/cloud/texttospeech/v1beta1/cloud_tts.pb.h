// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/texttospeech/v1beta1/cloud_tts.proto

#ifndef PROTOBUF_INCLUDED_google_2fcloud_2ftexttospeech_2fv1beta1_2fcloud_5ftts_2eproto
#define PROTOBUF_INCLUDED_google_2fcloud_2ftexttospeech_2fv1beta1_2fcloud_5ftts_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_google_2fcloud_2ftexttospeech_2fv1beta1_2fcloud_5ftts_2eproto 

namespace protobuf_google_2fcloud_2ftexttospeech_2fv1beta1_2fcloud_5ftts_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_google_2fcloud_2ftexttospeech_2fv1beta1_2fcloud_5ftts_2eproto
namespace google {
namespace cloud {
namespace texttospeech {
namespace v1beta1 {
class AudioConfig;
class AudioConfigDefaultTypeInternal;
extern AudioConfigDefaultTypeInternal _AudioConfig_default_instance_;
class ListVoicesRequest;
class ListVoicesRequestDefaultTypeInternal;
extern ListVoicesRequestDefaultTypeInternal _ListVoicesRequest_default_instance_;
class ListVoicesResponse;
class ListVoicesResponseDefaultTypeInternal;
extern ListVoicesResponseDefaultTypeInternal _ListVoicesResponse_default_instance_;
class SynthesisInput;
class SynthesisInputDefaultTypeInternal;
extern SynthesisInputDefaultTypeInternal _SynthesisInput_default_instance_;
class SynthesizeSpeechRequest;
class SynthesizeSpeechRequestDefaultTypeInternal;
extern SynthesizeSpeechRequestDefaultTypeInternal _SynthesizeSpeechRequest_default_instance_;
class SynthesizeSpeechResponse;
class SynthesizeSpeechResponseDefaultTypeInternal;
extern SynthesizeSpeechResponseDefaultTypeInternal _SynthesizeSpeechResponse_default_instance_;
class Voice;
class VoiceDefaultTypeInternal;
extern VoiceDefaultTypeInternal _Voice_default_instance_;
class VoiceSelectionParams;
class VoiceSelectionParamsDefaultTypeInternal;
extern VoiceSelectionParamsDefaultTypeInternal _VoiceSelectionParams_default_instance_;
}  // namespace v1beta1
}  // namespace texttospeech
}  // namespace cloud
}  // namespace google
namespace google {
namespace protobuf {
template<> ::google::cloud::texttospeech::v1beta1::AudioConfig* Arena::CreateMaybeMessage<::google::cloud::texttospeech::v1beta1::AudioConfig>(Arena*);
template<> ::google::cloud::texttospeech::v1beta1::ListVoicesRequest* Arena::CreateMaybeMessage<::google::cloud::texttospeech::v1beta1::ListVoicesRequest>(Arena*);
template<> ::google::cloud::texttospeech::v1beta1::ListVoicesResponse* Arena::CreateMaybeMessage<::google::cloud::texttospeech::v1beta1::ListVoicesResponse>(Arena*);
template<> ::google::cloud::texttospeech::v1beta1::SynthesisInput* Arena::CreateMaybeMessage<::google::cloud::texttospeech::v1beta1::SynthesisInput>(Arena*);
template<> ::google::cloud::texttospeech::v1beta1::SynthesizeSpeechRequest* Arena::CreateMaybeMessage<::google::cloud::texttospeech::v1beta1::SynthesizeSpeechRequest>(Arena*);
template<> ::google::cloud::texttospeech::v1beta1::SynthesizeSpeechResponse* Arena::CreateMaybeMessage<::google::cloud::texttospeech::v1beta1::SynthesizeSpeechResponse>(Arena*);
template<> ::google::cloud::texttospeech::v1beta1::Voice* Arena::CreateMaybeMessage<::google::cloud::texttospeech::v1beta1::Voice>(Arena*);
template<> ::google::cloud::texttospeech::v1beta1::VoiceSelectionParams* Arena::CreateMaybeMessage<::google::cloud::texttospeech::v1beta1::VoiceSelectionParams>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace google {
namespace cloud {
namespace texttospeech {
namespace v1beta1 {

enum SsmlVoiceGender {
  SSML_VOICE_GENDER_UNSPECIFIED = 0,
  MALE = 1,
  FEMALE = 2,
  NEUTRAL = 3,
  SsmlVoiceGender_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SsmlVoiceGender_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SsmlVoiceGender_IsValid(int value);
const SsmlVoiceGender SsmlVoiceGender_MIN = SSML_VOICE_GENDER_UNSPECIFIED;
const SsmlVoiceGender SsmlVoiceGender_MAX = NEUTRAL;
const int SsmlVoiceGender_ARRAYSIZE = SsmlVoiceGender_MAX + 1;

const ::google::protobuf::EnumDescriptor* SsmlVoiceGender_descriptor();
inline const ::std::string& SsmlVoiceGender_Name(SsmlVoiceGender value) {
  return ::google::protobuf::internal::NameOfEnum(
    SsmlVoiceGender_descriptor(), value);
}
inline bool SsmlVoiceGender_Parse(
    const ::std::string& name, SsmlVoiceGender* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SsmlVoiceGender>(
    SsmlVoiceGender_descriptor(), name, value);
}
enum AudioEncoding {
  AUDIO_ENCODING_UNSPECIFIED = 0,
  LINEAR16 = 1,
  MP3 = 2,
  OGG_OPUS = 3,
  AudioEncoding_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AudioEncoding_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AudioEncoding_IsValid(int value);
const AudioEncoding AudioEncoding_MIN = AUDIO_ENCODING_UNSPECIFIED;
const AudioEncoding AudioEncoding_MAX = OGG_OPUS;
const int AudioEncoding_ARRAYSIZE = AudioEncoding_MAX + 1;

const ::google::protobuf::EnumDescriptor* AudioEncoding_descriptor();
inline const ::std::string& AudioEncoding_Name(AudioEncoding value) {
  return ::google::protobuf::internal::NameOfEnum(
    AudioEncoding_descriptor(), value);
}
inline bool AudioEncoding_Parse(
    const ::std::string& name, AudioEncoding* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioEncoding>(
    AudioEncoding_descriptor(), name, value);
}
// ===================================================================

class ListVoicesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.texttospeech.v1beta1.ListVoicesRequest) */ {
 public:
  ListVoicesRequest();
  virtual ~ListVoicesRequest();

  ListVoicesRequest(const ListVoicesRequest& from);

  inline ListVoicesRequest& operator=(const ListVoicesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListVoicesRequest(ListVoicesRequest&& from) noexcept
    : ListVoicesRequest() {
    *this = ::std::move(from);
  }

  inline ListVoicesRequest& operator=(ListVoicesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListVoicesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListVoicesRequest* internal_default_instance() {
    return reinterpret_cast<const ListVoicesRequest*>(
               &_ListVoicesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(ListVoicesRequest* other);
  void Swap(ListVoicesRequest* other);
  friend void swap(ListVoicesRequest& a, ListVoicesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListVoicesRequest* New() const final {
    return CreateMaybeMessage<ListVoicesRequest>(NULL);
  }

  ListVoicesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListVoicesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListVoicesRequest& from);
  void MergeFrom(const ListVoicesRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListVoicesRequest* other);
  protected:
  explicit ListVoicesRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string language_code = 1;
  void clear_language_code();
  static const int kLanguageCodeFieldNumber = 1;
  const ::std::string& language_code() const;
  void set_language_code(const ::std::string& value);
  #if LANG_CXX11
  void set_language_code(::std::string&& value);
  #endif
  void set_language_code(const char* value);
  void set_language_code(const char* value, size_t size);
  ::std::string* mutable_language_code();
  ::std::string* release_language_code();
  void set_allocated_language_code(::std::string* language_code);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_language_code();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_language_code(
      ::std::string* language_code);

  // @@protoc_insertion_point(class_scope:google.cloud.texttospeech.v1beta1.ListVoicesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr language_code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_google_2fcloud_2ftexttospeech_2fv1beta1_2fcloud_5ftts_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListVoicesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.texttospeech.v1beta1.ListVoicesResponse) */ {
 public:
  ListVoicesResponse();
  virtual ~ListVoicesResponse();

  ListVoicesResponse(const ListVoicesResponse& from);

  inline ListVoicesResponse& operator=(const ListVoicesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListVoicesResponse(ListVoicesResponse&& from) noexcept
    : ListVoicesResponse() {
    *this = ::std::move(from);
  }

  inline ListVoicesResponse& operator=(ListVoicesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListVoicesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListVoicesResponse* internal_default_instance() {
    return reinterpret_cast<const ListVoicesResponse*>(
               &_ListVoicesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(ListVoicesResponse* other);
  void Swap(ListVoicesResponse* other);
  friend void swap(ListVoicesResponse& a, ListVoicesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListVoicesResponse* New() const final {
    return CreateMaybeMessage<ListVoicesResponse>(NULL);
  }

  ListVoicesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListVoicesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListVoicesResponse& from);
  void MergeFrom(const ListVoicesResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListVoicesResponse* other);
  protected:
  explicit ListVoicesResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.cloud.texttospeech.v1beta1.Voice voices = 1;
  int voices_size() const;
  void clear_voices();
  static const int kVoicesFieldNumber = 1;
  ::google::cloud::texttospeech::v1beta1::Voice* mutable_voices(int index);
  ::google::protobuf::RepeatedPtrField< ::google::cloud::texttospeech::v1beta1::Voice >*
      mutable_voices();
  const ::google::cloud::texttospeech::v1beta1::Voice& voices(int index) const;
  ::google::cloud::texttospeech::v1beta1::Voice* add_voices();
  const ::google::protobuf::RepeatedPtrField< ::google::cloud::texttospeech::v1beta1::Voice >&
      voices() const;

  // @@protoc_insertion_point(class_scope:google.cloud.texttospeech.v1beta1.ListVoicesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::google::cloud::texttospeech::v1beta1::Voice > voices_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_google_2fcloud_2ftexttospeech_2fv1beta1_2fcloud_5ftts_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Voice : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.texttospeech.v1beta1.Voice) */ {
 public:
  Voice();
  virtual ~Voice();

  Voice(const Voice& from);

  inline Voice& operator=(const Voice& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Voice(Voice&& from) noexcept
    : Voice() {
    *this = ::std::move(from);
  }

  inline Voice& operator=(Voice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Voice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Voice* internal_default_instance() {
    return reinterpret_cast<const Voice*>(
               &_Voice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(Voice* other);
  void Swap(Voice* other);
  friend void swap(Voice& a, Voice& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Voice* New() const final {
    return CreateMaybeMessage<Voice>(NULL);
  }

  Voice* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Voice>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Voice& from);
  void MergeFrom(const Voice& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Voice* other);
  protected:
  explicit Voice(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string language_codes = 1;
  int language_codes_size() const;
  void clear_language_codes();
  static const int kLanguageCodesFieldNumber = 1;
  const ::std::string& language_codes(int index) const;
  ::std::string* mutable_language_codes(int index);
  void set_language_codes(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_language_codes(int index, ::std::string&& value);
  #endif
  void set_language_codes(int index, const char* value);
  void set_language_codes(int index, const char* value, size_t size);
  ::std::string* add_language_codes();
  void add_language_codes(const ::std::string& value);
  #if LANG_CXX11
  void add_language_codes(::std::string&& value);
  #endif
  void add_language_codes(const char* value);
  void add_language_codes(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& language_codes() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_language_codes();

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // .google.cloud.texttospeech.v1beta1.SsmlVoiceGender ssml_gender = 3;
  void clear_ssml_gender();
  static const int kSsmlGenderFieldNumber = 3;
  ::google::cloud::texttospeech::v1beta1::SsmlVoiceGender ssml_gender() const;
  void set_ssml_gender(::google::cloud::texttospeech::v1beta1::SsmlVoiceGender value);

  // int32 natural_sample_rate_hertz = 4;
  void clear_natural_sample_rate_hertz();
  static const int kNaturalSampleRateHertzFieldNumber = 4;
  ::google::protobuf::int32 natural_sample_rate_hertz() const;
  void set_natural_sample_rate_hertz(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:google.cloud.texttospeech.v1beta1.Voice)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::std::string> language_codes_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int ssml_gender_;
  ::google::protobuf::int32 natural_sample_rate_hertz_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_google_2fcloud_2ftexttospeech_2fv1beta1_2fcloud_5ftts_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SynthesizeSpeechRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.texttospeech.v1beta1.SynthesizeSpeechRequest) */ {
 public:
  SynthesizeSpeechRequest();
  virtual ~SynthesizeSpeechRequest();

  SynthesizeSpeechRequest(const SynthesizeSpeechRequest& from);

  inline SynthesizeSpeechRequest& operator=(const SynthesizeSpeechRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SynthesizeSpeechRequest(SynthesizeSpeechRequest&& from) noexcept
    : SynthesizeSpeechRequest() {
    *this = ::std::move(from);
  }

  inline SynthesizeSpeechRequest& operator=(SynthesizeSpeechRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SynthesizeSpeechRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SynthesizeSpeechRequest* internal_default_instance() {
    return reinterpret_cast<const SynthesizeSpeechRequest*>(
               &_SynthesizeSpeechRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(SynthesizeSpeechRequest* other);
  void Swap(SynthesizeSpeechRequest* other);
  friend void swap(SynthesizeSpeechRequest& a, SynthesizeSpeechRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SynthesizeSpeechRequest* New() const final {
    return CreateMaybeMessage<SynthesizeSpeechRequest>(NULL);
  }

  SynthesizeSpeechRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SynthesizeSpeechRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SynthesizeSpeechRequest& from);
  void MergeFrom(const SynthesizeSpeechRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SynthesizeSpeechRequest* other);
  protected:
  explicit SynthesizeSpeechRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.cloud.texttospeech.v1beta1.SynthesisInput input = 1;
  bool has_input() const;
  void clear_input();
  static const int kInputFieldNumber = 1;
  private:
  const ::google::cloud::texttospeech::v1beta1::SynthesisInput& _internal_input() const;
  public:
  const ::google::cloud::texttospeech::v1beta1::SynthesisInput& input() const;
  ::google::cloud::texttospeech::v1beta1::SynthesisInput* release_input();
  ::google::cloud::texttospeech::v1beta1::SynthesisInput* mutable_input();
  void set_allocated_input(::google::cloud::texttospeech::v1beta1::SynthesisInput* input);
  void unsafe_arena_set_allocated_input(
      ::google::cloud::texttospeech::v1beta1::SynthesisInput* input);
  ::google::cloud::texttospeech::v1beta1::SynthesisInput* unsafe_arena_release_input();

  // .google.cloud.texttospeech.v1beta1.VoiceSelectionParams voice = 2;
  bool has_voice() const;
  void clear_voice();
  static const int kVoiceFieldNumber = 2;
  private:
  const ::google::cloud::texttospeech::v1beta1::VoiceSelectionParams& _internal_voice() const;
  public:
  const ::google::cloud::texttospeech::v1beta1::VoiceSelectionParams& voice() const;
  ::google::cloud::texttospeech::v1beta1::VoiceSelectionParams* release_voice();
  ::google::cloud::texttospeech::v1beta1::VoiceSelectionParams* mutable_voice();
  void set_allocated_voice(::google::cloud::texttospeech::v1beta1::VoiceSelectionParams* voice);
  void unsafe_arena_set_allocated_voice(
      ::google::cloud::texttospeech::v1beta1::VoiceSelectionParams* voice);
  ::google::cloud::texttospeech::v1beta1::VoiceSelectionParams* unsafe_arena_release_voice();

  // .google.cloud.texttospeech.v1beta1.AudioConfig audio_config = 3;
  bool has_audio_config() const;
  void clear_audio_config();
  static const int kAudioConfigFieldNumber = 3;
  private:
  const ::google::cloud::texttospeech::v1beta1::AudioConfig& _internal_audio_config() const;
  public:
  const ::google::cloud::texttospeech::v1beta1::AudioConfig& audio_config() const;
  ::google::cloud::texttospeech::v1beta1::AudioConfig* release_audio_config();
  ::google::cloud::texttospeech::v1beta1::AudioConfig* mutable_audio_config();
  void set_allocated_audio_config(::google::cloud::texttospeech::v1beta1::AudioConfig* audio_config);
  void unsafe_arena_set_allocated_audio_config(
      ::google::cloud::texttospeech::v1beta1::AudioConfig* audio_config);
  ::google::cloud::texttospeech::v1beta1::AudioConfig* unsafe_arena_release_audio_config();

  // @@protoc_insertion_point(class_scope:google.cloud.texttospeech.v1beta1.SynthesizeSpeechRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::cloud::texttospeech::v1beta1::SynthesisInput* input_;
  ::google::cloud::texttospeech::v1beta1::VoiceSelectionParams* voice_;
  ::google::cloud::texttospeech::v1beta1::AudioConfig* audio_config_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_google_2fcloud_2ftexttospeech_2fv1beta1_2fcloud_5ftts_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SynthesisInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.texttospeech.v1beta1.SynthesisInput) */ {
 public:
  SynthesisInput();
  virtual ~SynthesisInput();

  SynthesisInput(const SynthesisInput& from);

  inline SynthesisInput& operator=(const SynthesisInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SynthesisInput(SynthesisInput&& from) noexcept
    : SynthesisInput() {
    *this = ::std::move(from);
  }

  inline SynthesisInput& operator=(SynthesisInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SynthesisInput& default_instance();

  enum InputSourceCase {
    kText = 1,
    kSsml = 2,
    INPUT_SOURCE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SynthesisInput* internal_default_instance() {
    return reinterpret_cast<const SynthesisInput*>(
               &_SynthesisInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(SynthesisInput* other);
  void Swap(SynthesisInput* other);
  friend void swap(SynthesisInput& a, SynthesisInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SynthesisInput* New() const final {
    return CreateMaybeMessage<SynthesisInput>(NULL);
  }

  SynthesisInput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SynthesisInput>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SynthesisInput& from);
  void MergeFrom(const SynthesisInput& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SynthesisInput* other);
  protected:
  explicit SynthesisInput(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string text = 1;
  private:
  bool has_text() const;
  public:
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_text();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_text(
      ::std::string* text);

  // string ssml = 2;
  private:
  bool has_ssml() const;
  public:
  void clear_ssml();
  static const int kSsmlFieldNumber = 2;
  const ::std::string& ssml() const;
  void set_ssml(const ::std::string& value);
  #if LANG_CXX11
  void set_ssml(::std::string&& value);
  #endif
  void set_ssml(const char* value);
  void set_ssml(const char* value, size_t size);
  ::std::string* mutable_ssml();
  ::std::string* release_ssml();
  void set_allocated_ssml(::std::string* ssml);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_ssml();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ssml(
      ::std::string* ssml);

  void clear_input_source();
  InputSourceCase input_source_case() const;
  // @@protoc_insertion_point(class_scope:google.cloud.texttospeech.v1beta1.SynthesisInput)
 private:
  void set_has_text();
  void set_has_ssml();

  inline bool has_input_source() const;
  inline void clear_has_input_source();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union InputSourceUnion {
    InputSourceUnion() {}
    ::google::protobuf::internal::ArenaStringPtr text_;
    ::google::protobuf::internal::ArenaStringPtr ssml_;
  } input_source_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_google_2fcloud_2ftexttospeech_2fv1beta1_2fcloud_5ftts_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VoiceSelectionParams : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.texttospeech.v1beta1.VoiceSelectionParams) */ {
 public:
  VoiceSelectionParams();
  virtual ~VoiceSelectionParams();

  VoiceSelectionParams(const VoiceSelectionParams& from);

  inline VoiceSelectionParams& operator=(const VoiceSelectionParams& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VoiceSelectionParams(VoiceSelectionParams&& from) noexcept
    : VoiceSelectionParams() {
    *this = ::std::move(from);
  }

  inline VoiceSelectionParams& operator=(VoiceSelectionParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const VoiceSelectionParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VoiceSelectionParams* internal_default_instance() {
    return reinterpret_cast<const VoiceSelectionParams*>(
               &_VoiceSelectionParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(VoiceSelectionParams* other);
  void Swap(VoiceSelectionParams* other);
  friend void swap(VoiceSelectionParams& a, VoiceSelectionParams& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VoiceSelectionParams* New() const final {
    return CreateMaybeMessage<VoiceSelectionParams>(NULL);
  }

  VoiceSelectionParams* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VoiceSelectionParams>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VoiceSelectionParams& from);
  void MergeFrom(const VoiceSelectionParams& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoiceSelectionParams* other);
  protected:
  explicit VoiceSelectionParams(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string language_code = 1;
  void clear_language_code();
  static const int kLanguageCodeFieldNumber = 1;
  const ::std::string& language_code() const;
  void set_language_code(const ::std::string& value);
  #if LANG_CXX11
  void set_language_code(::std::string&& value);
  #endif
  void set_language_code(const char* value);
  void set_language_code(const char* value, size_t size);
  ::std::string* mutable_language_code();
  ::std::string* release_language_code();
  void set_allocated_language_code(::std::string* language_code);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_language_code();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_language_code(
      ::std::string* language_code);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // .google.cloud.texttospeech.v1beta1.SsmlVoiceGender ssml_gender = 3;
  void clear_ssml_gender();
  static const int kSsmlGenderFieldNumber = 3;
  ::google::cloud::texttospeech::v1beta1::SsmlVoiceGender ssml_gender() const;
  void set_ssml_gender(::google::cloud::texttospeech::v1beta1::SsmlVoiceGender value);

  // @@protoc_insertion_point(class_scope:google.cloud.texttospeech.v1beta1.VoiceSelectionParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr language_code_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int ssml_gender_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_google_2fcloud_2ftexttospeech_2fv1beta1_2fcloud_5ftts_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AudioConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.texttospeech.v1beta1.AudioConfig) */ {
 public:
  AudioConfig();
  virtual ~AudioConfig();

  AudioConfig(const AudioConfig& from);

  inline AudioConfig& operator=(const AudioConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AudioConfig(AudioConfig&& from) noexcept
    : AudioConfig() {
    *this = ::std::move(from);
  }

  inline AudioConfig& operator=(AudioConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AudioConfig* internal_default_instance() {
    return reinterpret_cast<const AudioConfig*>(
               &_AudioConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(AudioConfig* other);
  void Swap(AudioConfig* other);
  friend void swap(AudioConfig& a, AudioConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AudioConfig* New() const final {
    return CreateMaybeMessage<AudioConfig>(NULL);
  }

  AudioConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AudioConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AudioConfig& from);
  void MergeFrom(const AudioConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioConfig* other);
  protected:
  explicit AudioConfig(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string effects_profile_id = 6;
  int effects_profile_id_size() const;
  void clear_effects_profile_id();
  static const int kEffectsProfileIdFieldNumber = 6;
  const ::std::string& effects_profile_id(int index) const;
  ::std::string* mutable_effects_profile_id(int index);
  void set_effects_profile_id(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_effects_profile_id(int index, ::std::string&& value);
  #endif
  void set_effects_profile_id(int index, const char* value);
  void set_effects_profile_id(int index, const char* value, size_t size);
  ::std::string* add_effects_profile_id();
  void add_effects_profile_id(const ::std::string& value);
  #if LANG_CXX11
  void add_effects_profile_id(::std::string&& value);
  #endif
  void add_effects_profile_id(const char* value);
  void add_effects_profile_id(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& effects_profile_id() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_effects_profile_id();

  // double speaking_rate = 2;
  void clear_speaking_rate();
  static const int kSpeakingRateFieldNumber = 2;
  double speaking_rate() const;
  void set_speaking_rate(double value);

  // double pitch = 3;
  void clear_pitch();
  static const int kPitchFieldNumber = 3;
  double pitch() const;
  void set_pitch(double value);

  // .google.cloud.texttospeech.v1beta1.AudioEncoding audio_encoding = 1;
  void clear_audio_encoding();
  static const int kAudioEncodingFieldNumber = 1;
  ::google::cloud::texttospeech::v1beta1::AudioEncoding audio_encoding() const;
  void set_audio_encoding(::google::cloud::texttospeech::v1beta1::AudioEncoding value);

  // int32 sample_rate_hertz = 5;
  void clear_sample_rate_hertz();
  static const int kSampleRateHertzFieldNumber = 5;
  ::google::protobuf::int32 sample_rate_hertz() const;
  void set_sample_rate_hertz(::google::protobuf::int32 value);

  // double volume_gain_db = 4;
  void clear_volume_gain_db();
  static const int kVolumeGainDbFieldNumber = 4;
  double volume_gain_db() const;
  void set_volume_gain_db(double value);

  // @@protoc_insertion_point(class_scope:google.cloud.texttospeech.v1beta1.AudioConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::std::string> effects_profile_id_;
  double speaking_rate_;
  double pitch_;
  int audio_encoding_;
  ::google::protobuf::int32 sample_rate_hertz_;
  double volume_gain_db_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_google_2fcloud_2ftexttospeech_2fv1beta1_2fcloud_5ftts_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SynthesizeSpeechResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.texttospeech.v1beta1.SynthesizeSpeechResponse) */ {
 public:
  SynthesizeSpeechResponse();
  virtual ~SynthesizeSpeechResponse();

  SynthesizeSpeechResponse(const SynthesizeSpeechResponse& from);

  inline SynthesizeSpeechResponse& operator=(const SynthesizeSpeechResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SynthesizeSpeechResponse(SynthesizeSpeechResponse&& from) noexcept
    : SynthesizeSpeechResponse() {
    *this = ::std::move(from);
  }

  inline SynthesizeSpeechResponse& operator=(SynthesizeSpeechResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SynthesizeSpeechResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SynthesizeSpeechResponse* internal_default_instance() {
    return reinterpret_cast<const SynthesizeSpeechResponse*>(
               &_SynthesizeSpeechResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(SynthesizeSpeechResponse* other);
  void Swap(SynthesizeSpeechResponse* other);
  friend void swap(SynthesizeSpeechResponse& a, SynthesizeSpeechResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SynthesizeSpeechResponse* New() const final {
    return CreateMaybeMessage<SynthesizeSpeechResponse>(NULL);
  }

  SynthesizeSpeechResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SynthesizeSpeechResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SynthesizeSpeechResponse& from);
  void MergeFrom(const SynthesizeSpeechResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SynthesizeSpeechResponse* other);
  protected:
  explicit SynthesizeSpeechResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes audio_content = 1;
  void clear_audio_content();
  static const int kAudioContentFieldNumber = 1;
  const ::std::string& audio_content() const;
  void set_audio_content(const ::std::string& value);
  #if LANG_CXX11
  void set_audio_content(::std::string&& value);
  #endif
  void set_audio_content(const char* value);
  void set_audio_content(const void* value, size_t size);
  ::std::string* mutable_audio_content();
  ::std::string* release_audio_content();
  void set_allocated_audio_content(::std::string* audio_content);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_audio_content();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_audio_content(
      ::std::string* audio_content);

  // @@protoc_insertion_point(class_scope:google.cloud.texttospeech.v1beta1.SynthesizeSpeechResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr audio_content_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_google_2fcloud_2ftexttospeech_2fv1beta1_2fcloud_5ftts_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ListVoicesRequest

// string language_code = 1;
inline void ListVoicesRequest::clear_language_code() {
  language_code_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& ListVoicesRequest::language_code() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1beta1.ListVoicesRequest.language_code)
  return language_code_.Get();
}
inline void ListVoicesRequest::set_language_code(const ::std::string& value) {
  
  language_code_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1beta1.ListVoicesRequest.language_code)
}
#if LANG_CXX11
inline void ListVoicesRequest::set_language_code(::std::string&& value) {
  
  language_code_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.texttospeech.v1beta1.ListVoicesRequest.language_code)
}
#endif
inline void ListVoicesRequest::set_language_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  language_code_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:google.cloud.texttospeech.v1beta1.ListVoicesRequest.language_code)
}
inline void ListVoicesRequest::set_language_code(const char* value,
    size_t size) {
  
  language_code_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:google.cloud.texttospeech.v1beta1.ListVoicesRequest.language_code)
}
inline ::std::string* ListVoicesRequest::mutable_language_code() {
  
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1beta1.ListVoicesRequest.language_code)
  return language_code_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ListVoicesRequest::release_language_code() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1beta1.ListVoicesRequest.language_code)
  
  return language_code_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ListVoicesRequest::set_allocated_language_code(::std::string* language_code) {
  if (language_code != NULL) {
    
  } else {
    
  }
  language_code_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language_code,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1beta1.ListVoicesRequest.language_code)
}
inline ::std::string* ListVoicesRequest::unsafe_arena_release_language_code() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.cloud.texttospeech.v1beta1.ListVoicesRequest.language_code)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return language_code_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ListVoicesRequest::unsafe_arena_set_allocated_language_code(
    ::std::string* language_code) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (language_code != NULL) {
    
  } else {
    
  }
  language_code_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      language_code, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.cloud.texttospeech.v1beta1.ListVoicesRequest.language_code)
}

// -------------------------------------------------------------------

// ListVoicesResponse

// repeated .google.cloud.texttospeech.v1beta1.Voice voices = 1;
inline int ListVoicesResponse::voices_size() const {
  return voices_.size();
}
inline void ListVoicesResponse::clear_voices() {
  voices_.Clear();
}
inline ::google::cloud::texttospeech::v1beta1::Voice* ListVoicesResponse::mutable_voices(int index) {
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1beta1.ListVoicesResponse.voices)
  return voices_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::cloud::texttospeech::v1beta1::Voice >*
ListVoicesResponse::mutable_voices() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.texttospeech.v1beta1.ListVoicesResponse.voices)
  return &voices_;
}
inline const ::google::cloud::texttospeech::v1beta1::Voice& ListVoicesResponse::voices(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1beta1.ListVoicesResponse.voices)
  return voices_.Get(index);
}
inline ::google::cloud::texttospeech::v1beta1::Voice* ListVoicesResponse::add_voices() {
  // @@protoc_insertion_point(field_add:google.cloud.texttospeech.v1beta1.ListVoicesResponse.voices)
  return voices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::cloud::texttospeech::v1beta1::Voice >&
ListVoicesResponse::voices() const {
  // @@protoc_insertion_point(field_list:google.cloud.texttospeech.v1beta1.ListVoicesResponse.voices)
  return voices_;
}

// -------------------------------------------------------------------

// Voice

// repeated string language_codes = 1;
inline int Voice::language_codes_size() const {
  return language_codes_.size();
}
inline void Voice::clear_language_codes() {
  language_codes_.Clear();
}
inline const ::std::string& Voice::language_codes(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1beta1.Voice.language_codes)
  return language_codes_.Get(index);
}
inline ::std::string* Voice::mutable_language_codes(int index) {
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1beta1.Voice.language_codes)
  return language_codes_.Mutable(index);
}
inline void Voice::set_language_codes(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1beta1.Voice.language_codes)
  language_codes_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Voice::set_language_codes(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1beta1.Voice.language_codes)
  language_codes_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Voice::set_language_codes(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  language_codes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.cloud.texttospeech.v1beta1.Voice.language_codes)
}
inline void Voice::set_language_codes(int index, const char* value, size_t size) {
  language_codes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.cloud.texttospeech.v1beta1.Voice.language_codes)
}
inline ::std::string* Voice::add_language_codes() {
  // @@protoc_insertion_point(field_add_mutable:google.cloud.texttospeech.v1beta1.Voice.language_codes)
  return language_codes_.Add();
}
inline void Voice::add_language_codes(const ::std::string& value) {
  language_codes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.cloud.texttospeech.v1beta1.Voice.language_codes)
}
#if LANG_CXX11
inline void Voice::add_language_codes(::std::string&& value) {
  language_codes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.cloud.texttospeech.v1beta1.Voice.language_codes)
}
#endif
inline void Voice::add_language_codes(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  language_codes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.cloud.texttospeech.v1beta1.Voice.language_codes)
}
inline void Voice::add_language_codes(const char* value, size_t size) {
  language_codes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.cloud.texttospeech.v1beta1.Voice.language_codes)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Voice::language_codes() const {
  // @@protoc_insertion_point(field_list:google.cloud.texttospeech.v1beta1.Voice.language_codes)
  return language_codes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Voice::mutable_language_codes() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.texttospeech.v1beta1.Voice.language_codes)
  return &language_codes_;
}

// string name = 2;
inline void Voice::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& Voice::name() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1beta1.Voice.name)
  return name_.Get();
}
inline void Voice::set_name(const ::std::string& value) {
  
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1beta1.Voice.name)
}
#if LANG_CXX11
inline void Voice::set_name(::std::string&& value) {
  
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.texttospeech.v1beta1.Voice.name)
}
#endif
inline void Voice::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:google.cloud.texttospeech.v1beta1.Voice.name)
}
inline void Voice::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:google.cloud.texttospeech.v1beta1.Voice.name)
}
inline ::std::string* Voice::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1beta1.Voice.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Voice::release_name() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1beta1.Voice.name)
  
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Voice::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1beta1.Voice.name)
}
inline ::std::string* Voice::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.cloud.texttospeech.v1beta1.Voice.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Voice::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.cloud.texttospeech.v1beta1.Voice.name)
}

// .google.cloud.texttospeech.v1beta1.SsmlVoiceGender ssml_gender = 3;
inline void Voice::clear_ssml_gender() {
  ssml_gender_ = 0;
}
inline ::google::cloud::texttospeech::v1beta1::SsmlVoiceGender Voice::ssml_gender() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1beta1.Voice.ssml_gender)
  return static_cast< ::google::cloud::texttospeech::v1beta1::SsmlVoiceGender >(ssml_gender_);
}
inline void Voice::set_ssml_gender(::google::cloud::texttospeech::v1beta1::SsmlVoiceGender value) {
  
  ssml_gender_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1beta1.Voice.ssml_gender)
}

// int32 natural_sample_rate_hertz = 4;
inline void Voice::clear_natural_sample_rate_hertz() {
  natural_sample_rate_hertz_ = 0;
}
inline ::google::protobuf::int32 Voice::natural_sample_rate_hertz() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1beta1.Voice.natural_sample_rate_hertz)
  return natural_sample_rate_hertz_;
}
inline void Voice::set_natural_sample_rate_hertz(::google::protobuf::int32 value) {
  
  natural_sample_rate_hertz_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1beta1.Voice.natural_sample_rate_hertz)
}

// -------------------------------------------------------------------

// SynthesizeSpeechRequest

// .google.cloud.texttospeech.v1beta1.SynthesisInput input = 1;
inline bool SynthesizeSpeechRequest::has_input() const {
  return this != internal_default_instance() && input_ != NULL;
}
inline void SynthesizeSpeechRequest::clear_input() {
  if (GetArenaNoVirtual() == NULL && input_ != NULL) {
    delete input_;
  }
  input_ = NULL;
}
inline const ::google::cloud::texttospeech::v1beta1::SynthesisInput& SynthesizeSpeechRequest::_internal_input() const {
  return *input_;
}
inline const ::google::cloud::texttospeech::v1beta1::SynthesisInput& SynthesizeSpeechRequest::input() const {
  const ::google::cloud::texttospeech::v1beta1::SynthesisInput* p = input_;
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1beta1.SynthesizeSpeechRequest.input)
  return p != NULL ? *p : *reinterpret_cast<const ::google::cloud::texttospeech::v1beta1::SynthesisInput*>(
      &::google::cloud::texttospeech::v1beta1::_SynthesisInput_default_instance_);
}
inline ::google::cloud::texttospeech::v1beta1::SynthesisInput* SynthesizeSpeechRequest::release_input() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1beta1.SynthesizeSpeechRequest.input)
  
  ::google::cloud::texttospeech::v1beta1::SynthesisInput* temp = input_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  input_ = NULL;
  return temp;
}
inline ::google::cloud::texttospeech::v1beta1::SynthesisInput* SynthesizeSpeechRequest::unsafe_arena_release_input() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.cloud.texttospeech.v1beta1.SynthesizeSpeechRequest.input)
  
  ::google::cloud::texttospeech::v1beta1::SynthesisInput* temp = input_;
  input_ = NULL;
  return temp;
}
inline ::google::cloud::texttospeech::v1beta1::SynthesisInput* SynthesizeSpeechRequest::mutable_input() {
  
  if (input_ == NULL) {
    auto* p = CreateMaybeMessage<::google::cloud::texttospeech::v1beta1::SynthesisInput>(GetArenaNoVirtual());
    input_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1beta1.SynthesizeSpeechRequest.input)
  return input_;
}
inline void SynthesizeSpeechRequest::set_allocated_input(::google::cloud::texttospeech::v1beta1::SynthesisInput* input) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete input_;
  }
  if (input) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(input);
    if (message_arena != submessage_arena) {
      input = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1beta1.SynthesizeSpeechRequest.input)
}

// .google.cloud.texttospeech.v1beta1.VoiceSelectionParams voice = 2;
inline bool SynthesizeSpeechRequest::has_voice() const {
  return this != internal_default_instance() && voice_ != NULL;
}
inline void SynthesizeSpeechRequest::clear_voice() {
  if (GetArenaNoVirtual() == NULL && voice_ != NULL) {
    delete voice_;
  }
  voice_ = NULL;
}
inline const ::google::cloud::texttospeech::v1beta1::VoiceSelectionParams& SynthesizeSpeechRequest::_internal_voice() const {
  return *voice_;
}
inline const ::google::cloud::texttospeech::v1beta1::VoiceSelectionParams& SynthesizeSpeechRequest::voice() const {
  const ::google::cloud::texttospeech::v1beta1::VoiceSelectionParams* p = voice_;
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1beta1.SynthesizeSpeechRequest.voice)
  return p != NULL ? *p : *reinterpret_cast<const ::google::cloud::texttospeech::v1beta1::VoiceSelectionParams*>(
      &::google::cloud::texttospeech::v1beta1::_VoiceSelectionParams_default_instance_);
}
inline ::google::cloud::texttospeech::v1beta1::VoiceSelectionParams* SynthesizeSpeechRequest::release_voice() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1beta1.SynthesizeSpeechRequest.voice)
  
  ::google::cloud::texttospeech::v1beta1::VoiceSelectionParams* temp = voice_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  voice_ = NULL;
  return temp;
}
inline ::google::cloud::texttospeech::v1beta1::VoiceSelectionParams* SynthesizeSpeechRequest::unsafe_arena_release_voice() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.cloud.texttospeech.v1beta1.SynthesizeSpeechRequest.voice)
  
  ::google::cloud::texttospeech::v1beta1::VoiceSelectionParams* temp = voice_;
  voice_ = NULL;
  return temp;
}
inline ::google::cloud::texttospeech::v1beta1::VoiceSelectionParams* SynthesizeSpeechRequest::mutable_voice() {
  
  if (voice_ == NULL) {
    auto* p = CreateMaybeMessage<::google::cloud::texttospeech::v1beta1::VoiceSelectionParams>(GetArenaNoVirtual());
    voice_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1beta1.SynthesizeSpeechRequest.voice)
  return voice_;
}
inline void SynthesizeSpeechRequest::set_allocated_voice(::google::cloud::texttospeech::v1beta1::VoiceSelectionParams* voice) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete voice_;
  }
  if (voice) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(voice);
    if (message_arena != submessage_arena) {
      voice = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, voice, submessage_arena);
    }
    
  } else {
    
  }
  voice_ = voice;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1beta1.SynthesizeSpeechRequest.voice)
}

// .google.cloud.texttospeech.v1beta1.AudioConfig audio_config = 3;
inline bool SynthesizeSpeechRequest::has_audio_config() const {
  return this != internal_default_instance() && audio_config_ != NULL;
}
inline void SynthesizeSpeechRequest::clear_audio_config() {
  if (GetArenaNoVirtual() == NULL && audio_config_ != NULL) {
    delete audio_config_;
  }
  audio_config_ = NULL;
}
inline const ::google::cloud::texttospeech::v1beta1::AudioConfig& SynthesizeSpeechRequest::_internal_audio_config() const {
  return *audio_config_;
}
inline const ::google::cloud::texttospeech::v1beta1::AudioConfig& SynthesizeSpeechRequest::audio_config() const {
  const ::google::cloud::texttospeech::v1beta1::AudioConfig* p = audio_config_;
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1beta1.SynthesizeSpeechRequest.audio_config)
  return p != NULL ? *p : *reinterpret_cast<const ::google::cloud::texttospeech::v1beta1::AudioConfig*>(
      &::google::cloud::texttospeech::v1beta1::_AudioConfig_default_instance_);
}
inline ::google::cloud::texttospeech::v1beta1::AudioConfig* SynthesizeSpeechRequest::release_audio_config() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1beta1.SynthesizeSpeechRequest.audio_config)
  
  ::google::cloud::texttospeech::v1beta1::AudioConfig* temp = audio_config_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  audio_config_ = NULL;
  return temp;
}
inline ::google::cloud::texttospeech::v1beta1::AudioConfig* SynthesizeSpeechRequest::unsafe_arena_release_audio_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.cloud.texttospeech.v1beta1.SynthesizeSpeechRequest.audio_config)
  
  ::google::cloud::texttospeech::v1beta1::AudioConfig* temp = audio_config_;
  audio_config_ = NULL;
  return temp;
}
inline ::google::cloud::texttospeech::v1beta1::AudioConfig* SynthesizeSpeechRequest::mutable_audio_config() {
  
  if (audio_config_ == NULL) {
    auto* p = CreateMaybeMessage<::google::cloud::texttospeech::v1beta1::AudioConfig>(GetArenaNoVirtual());
    audio_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1beta1.SynthesizeSpeechRequest.audio_config)
  return audio_config_;
}
inline void SynthesizeSpeechRequest::set_allocated_audio_config(::google::cloud::texttospeech::v1beta1::AudioConfig* audio_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete audio_config_;
  }
  if (audio_config) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(audio_config);
    if (message_arena != submessage_arena) {
      audio_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, audio_config, submessage_arena);
    }
    
  } else {
    
  }
  audio_config_ = audio_config;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1beta1.SynthesizeSpeechRequest.audio_config)
}

// -------------------------------------------------------------------

// SynthesisInput

// string text = 1;
inline bool SynthesisInput::has_text() const {
  return input_source_case() == kText;
}
inline void SynthesisInput::set_has_text() {
  _oneof_case_[0] = kText;
}
inline void SynthesisInput::clear_text() {
  if (has_text()) {
    input_source_.text_.Destroy(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
    clear_has_input_source();
  }
}
inline const ::std::string& SynthesisInput::text() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1beta1.SynthesisInput.text)
  if (has_text()) {
    return input_source_.text_.Get();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void SynthesisInput::set_text(const ::std::string& value) {
  if (!has_text()) {
    clear_input_source();
    set_has_text();
    input_source_.text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  input_source_.text_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1beta1.SynthesisInput.text)
}
#if LANG_CXX11
inline void SynthesisInput::set_text(::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1beta1.SynthesisInput.text)
  if (!has_text()) {
    clear_input_source();
    set_has_text();
    input_source_.text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  input_source_.text_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.texttospeech.v1beta1.SynthesisInput.text)
}
#endif
inline void SynthesisInput::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_text()) {
    clear_input_source();
    set_has_text();
    input_source_.text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  input_source_.text_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:google.cloud.texttospeech.v1beta1.SynthesisInput.text)
}
inline void SynthesisInput::set_text(const char* value,
                             size_t size) {
  if (!has_text()) {
    clear_input_source();
    set_has_text();
    input_source_.text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  input_source_.text_.Set(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:google.cloud.texttospeech.v1beta1.SynthesisInput.text)
}
inline ::std::string* SynthesisInput::mutable_text() {
  if (!has_text()) {
    clear_input_source();
    set_has_text();
    input_source_.text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return input_source_.text_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1beta1.SynthesisInput.text)
}
inline ::std::string* SynthesisInput::release_text() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1beta1.SynthesisInput.text)
  if (has_text()) {
    clear_has_input_source();
    return input_source_.text_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline void SynthesisInput::set_allocated_text(::std::string* text) {
  if (!has_text()) {
    input_source_.text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_input_source();
  if (text != NULL) {
    set_has_text();
    input_source_.text_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text,
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1beta1.SynthesisInput.text)
}
inline ::std::string* SynthesisInput::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.cloud.texttospeech.v1beta1.SynthesisInput.text)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (has_text()) {
    clear_has_input_source();
    return input_source_.text_.UnsafeArenaRelease(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline void SynthesisInput::unsafe_arena_set_allocated_text(::std::string* text) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (!has_text()) {
    input_source_.text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_input_source();
  if (text) {
    set_has_text();
    input_source_.text_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text, GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.cloud.texttospeech.v1beta1.SynthesisInput.text)
}

// string ssml = 2;
inline bool SynthesisInput::has_ssml() const {
  return input_source_case() == kSsml;
}
inline void SynthesisInput::set_has_ssml() {
  _oneof_case_[0] = kSsml;
}
inline void SynthesisInput::clear_ssml() {
  if (has_ssml()) {
    input_source_.ssml_.Destroy(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
    clear_has_input_source();
  }
}
inline const ::std::string& SynthesisInput::ssml() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1beta1.SynthesisInput.ssml)
  if (has_ssml()) {
    return input_source_.ssml_.Get();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void SynthesisInput::set_ssml(const ::std::string& value) {
  if (!has_ssml()) {
    clear_input_source();
    set_has_ssml();
    input_source_.ssml_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  input_source_.ssml_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1beta1.SynthesisInput.ssml)
}
#if LANG_CXX11
inline void SynthesisInput::set_ssml(::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1beta1.SynthesisInput.ssml)
  if (!has_ssml()) {
    clear_input_source();
    set_has_ssml();
    input_source_.ssml_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  input_source_.ssml_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.texttospeech.v1beta1.SynthesisInput.ssml)
}
#endif
inline void SynthesisInput::set_ssml(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_ssml()) {
    clear_input_source();
    set_has_ssml();
    input_source_.ssml_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  input_source_.ssml_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:google.cloud.texttospeech.v1beta1.SynthesisInput.ssml)
}
inline void SynthesisInput::set_ssml(const char* value,
                             size_t size) {
  if (!has_ssml()) {
    clear_input_source();
    set_has_ssml();
    input_source_.ssml_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  input_source_.ssml_.Set(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:google.cloud.texttospeech.v1beta1.SynthesisInput.ssml)
}
inline ::std::string* SynthesisInput::mutable_ssml() {
  if (!has_ssml()) {
    clear_input_source();
    set_has_ssml();
    input_source_.ssml_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return input_source_.ssml_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1beta1.SynthesisInput.ssml)
}
inline ::std::string* SynthesisInput::release_ssml() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1beta1.SynthesisInput.ssml)
  if (has_ssml()) {
    clear_has_input_source();
    return input_source_.ssml_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline void SynthesisInput::set_allocated_ssml(::std::string* ssml) {
  if (!has_ssml()) {
    input_source_.ssml_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_input_source();
  if (ssml != NULL) {
    set_has_ssml();
    input_source_.ssml_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ssml,
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1beta1.SynthesisInput.ssml)
}
inline ::std::string* SynthesisInput::unsafe_arena_release_ssml() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.cloud.texttospeech.v1beta1.SynthesisInput.ssml)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (has_ssml()) {
    clear_has_input_source();
    return input_source_.ssml_.UnsafeArenaRelease(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline void SynthesisInput::unsafe_arena_set_allocated_ssml(::std::string* ssml) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (!has_ssml()) {
    input_source_.ssml_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_input_source();
  if (ssml) {
    set_has_ssml();
    input_source_.ssml_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ssml, GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.cloud.texttospeech.v1beta1.SynthesisInput.ssml)
}

inline bool SynthesisInput::has_input_source() const {
  return input_source_case() != INPUT_SOURCE_NOT_SET;
}
inline void SynthesisInput::clear_has_input_source() {
  _oneof_case_[0] = INPUT_SOURCE_NOT_SET;
}
inline SynthesisInput::InputSourceCase SynthesisInput::input_source_case() const {
  return SynthesisInput::InputSourceCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// VoiceSelectionParams

// string language_code = 1;
inline void VoiceSelectionParams::clear_language_code() {
  language_code_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& VoiceSelectionParams::language_code() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.language_code)
  return language_code_.Get();
}
inline void VoiceSelectionParams::set_language_code(const ::std::string& value) {
  
  language_code_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.language_code)
}
#if LANG_CXX11
inline void VoiceSelectionParams::set_language_code(::std::string&& value) {
  
  language_code_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.language_code)
}
#endif
inline void VoiceSelectionParams::set_language_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  language_code_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.language_code)
}
inline void VoiceSelectionParams::set_language_code(const char* value,
    size_t size) {
  
  language_code_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.language_code)
}
inline ::std::string* VoiceSelectionParams::mutable_language_code() {
  
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.language_code)
  return language_code_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* VoiceSelectionParams::release_language_code() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.language_code)
  
  return language_code_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void VoiceSelectionParams::set_allocated_language_code(::std::string* language_code) {
  if (language_code != NULL) {
    
  } else {
    
  }
  language_code_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language_code,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.language_code)
}
inline ::std::string* VoiceSelectionParams::unsafe_arena_release_language_code() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.language_code)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return language_code_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void VoiceSelectionParams::unsafe_arena_set_allocated_language_code(
    ::std::string* language_code) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (language_code != NULL) {
    
  } else {
    
  }
  language_code_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      language_code, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.language_code)
}

// string name = 2;
inline void VoiceSelectionParams::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& VoiceSelectionParams::name() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.name)
  return name_.Get();
}
inline void VoiceSelectionParams::set_name(const ::std::string& value) {
  
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.name)
}
#if LANG_CXX11
inline void VoiceSelectionParams::set_name(::std::string&& value) {
  
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.name)
}
#endif
inline void VoiceSelectionParams::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.name)
}
inline void VoiceSelectionParams::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.name)
}
inline ::std::string* VoiceSelectionParams::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* VoiceSelectionParams::release_name() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.name)
  
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void VoiceSelectionParams::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.name)
}
inline ::std::string* VoiceSelectionParams::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void VoiceSelectionParams::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.name)
}

// .google.cloud.texttospeech.v1beta1.SsmlVoiceGender ssml_gender = 3;
inline void VoiceSelectionParams::clear_ssml_gender() {
  ssml_gender_ = 0;
}
inline ::google::cloud::texttospeech::v1beta1::SsmlVoiceGender VoiceSelectionParams::ssml_gender() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.ssml_gender)
  return static_cast< ::google::cloud::texttospeech::v1beta1::SsmlVoiceGender >(ssml_gender_);
}
inline void VoiceSelectionParams::set_ssml_gender(::google::cloud::texttospeech::v1beta1::SsmlVoiceGender value) {
  
  ssml_gender_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1beta1.VoiceSelectionParams.ssml_gender)
}

// -------------------------------------------------------------------

// AudioConfig

// .google.cloud.texttospeech.v1beta1.AudioEncoding audio_encoding = 1;
inline void AudioConfig::clear_audio_encoding() {
  audio_encoding_ = 0;
}
inline ::google::cloud::texttospeech::v1beta1::AudioEncoding AudioConfig::audio_encoding() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1beta1.AudioConfig.audio_encoding)
  return static_cast< ::google::cloud::texttospeech::v1beta1::AudioEncoding >(audio_encoding_);
}
inline void AudioConfig::set_audio_encoding(::google::cloud::texttospeech::v1beta1::AudioEncoding value) {
  
  audio_encoding_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1beta1.AudioConfig.audio_encoding)
}

// double speaking_rate = 2;
inline void AudioConfig::clear_speaking_rate() {
  speaking_rate_ = 0;
}
inline double AudioConfig::speaking_rate() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1beta1.AudioConfig.speaking_rate)
  return speaking_rate_;
}
inline void AudioConfig::set_speaking_rate(double value) {
  
  speaking_rate_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1beta1.AudioConfig.speaking_rate)
}

// double pitch = 3;
inline void AudioConfig::clear_pitch() {
  pitch_ = 0;
}
inline double AudioConfig::pitch() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1beta1.AudioConfig.pitch)
  return pitch_;
}
inline void AudioConfig::set_pitch(double value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1beta1.AudioConfig.pitch)
}

// double volume_gain_db = 4;
inline void AudioConfig::clear_volume_gain_db() {
  volume_gain_db_ = 0;
}
inline double AudioConfig::volume_gain_db() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1beta1.AudioConfig.volume_gain_db)
  return volume_gain_db_;
}
inline void AudioConfig::set_volume_gain_db(double value) {
  
  volume_gain_db_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1beta1.AudioConfig.volume_gain_db)
}

// int32 sample_rate_hertz = 5;
inline void AudioConfig::clear_sample_rate_hertz() {
  sample_rate_hertz_ = 0;
}
inline ::google::protobuf::int32 AudioConfig::sample_rate_hertz() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1beta1.AudioConfig.sample_rate_hertz)
  return sample_rate_hertz_;
}
inline void AudioConfig::set_sample_rate_hertz(::google::protobuf::int32 value) {
  
  sample_rate_hertz_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1beta1.AudioConfig.sample_rate_hertz)
}

// repeated string effects_profile_id = 6;
inline int AudioConfig::effects_profile_id_size() const {
  return effects_profile_id_.size();
}
inline void AudioConfig::clear_effects_profile_id() {
  effects_profile_id_.Clear();
}
inline const ::std::string& AudioConfig::effects_profile_id(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1beta1.AudioConfig.effects_profile_id)
  return effects_profile_id_.Get(index);
}
inline ::std::string* AudioConfig::mutable_effects_profile_id(int index) {
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1beta1.AudioConfig.effects_profile_id)
  return effects_profile_id_.Mutable(index);
}
inline void AudioConfig::set_effects_profile_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1beta1.AudioConfig.effects_profile_id)
  effects_profile_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AudioConfig::set_effects_profile_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1beta1.AudioConfig.effects_profile_id)
  effects_profile_id_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AudioConfig::set_effects_profile_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  effects_profile_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.cloud.texttospeech.v1beta1.AudioConfig.effects_profile_id)
}
inline void AudioConfig::set_effects_profile_id(int index, const char* value, size_t size) {
  effects_profile_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.cloud.texttospeech.v1beta1.AudioConfig.effects_profile_id)
}
inline ::std::string* AudioConfig::add_effects_profile_id() {
  // @@protoc_insertion_point(field_add_mutable:google.cloud.texttospeech.v1beta1.AudioConfig.effects_profile_id)
  return effects_profile_id_.Add();
}
inline void AudioConfig::add_effects_profile_id(const ::std::string& value) {
  effects_profile_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.cloud.texttospeech.v1beta1.AudioConfig.effects_profile_id)
}
#if LANG_CXX11
inline void AudioConfig::add_effects_profile_id(::std::string&& value) {
  effects_profile_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.cloud.texttospeech.v1beta1.AudioConfig.effects_profile_id)
}
#endif
inline void AudioConfig::add_effects_profile_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  effects_profile_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.cloud.texttospeech.v1beta1.AudioConfig.effects_profile_id)
}
inline void AudioConfig::add_effects_profile_id(const char* value, size_t size) {
  effects_profile_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.cloud.texttospeech.v1beta1.AudioConfig.effects_profile_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AudioConfig::effects_profile_id() const {
  // @@protoc_insertion_point(field_list:google.cloud.texttospeech.v1beta1.AudioConfig.effects_profile_id)
  return effects_profile_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AudioConfig::mutable_effects_profile_id() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.texttospeech.v1beta1.AudioConfig.effects_profile_id)
  return &effects_profile_id_;
}

// -------------------------------------------------------------------

// SynthesizeSpeechResponse

// bytes audio_content = 1;
inline void SynthesizeSpeechResponse::clear_audio_content() {
  audio_content_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& SynthesizeSpeechResponse::audio_content() const {
  // @@protoc_insertion_point(field_get:google.cloud.texttospeech.v1beta1.SynthesizeSpeechResponse.audio_content)
  return audio_content_.Get();
}
inline void SynthesizeSpeechResponse::set_audio_content(const ::std::string& value) {
  
  audio_content_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:google.cloud.texttospeech.v1beta1.SynthesizeSpeechResponse.audio_content)
}
#if LANG_CXX11
inline void SynthesizeSpeechResponse::set_audio_content(::std::string&& value) {
  
  audio_content_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.texttospeech.v1beta1.SynthesizeSpeechResponse.audio_content)
}
#endif
inline void SynthesizeSpeechResponse::set_audio_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  audio_content_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:google.cloud.texttospeech.v1beta1.SynthesizeSpeechResponse.audio_content)
}
inline void SynthesizeSpeechResponse::set_audio_content(const void* value,
    size_t size) {
  
  audio_content_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:google.cloud.texttospeech.v1beta1.SynthesizeSpeechResponse.audio_content)
}
inline ::std::string* SynthesizeSpeechResponse::mutable_audio_content() {
  
  // @@protoc_insertion_point(field_mutable:google.cloud.texttospeech.v1beta1.SynthesizeSpeechResponse.audio_content)
  return audio_content_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* SynthesizeSpeechResponse::release_audio_content() {
  // @@protoc_insertion_point(field_release:google.cloud.texttospeech.v1beta1.SynthesizeSpeechResponse.audio_content)
  
  return audio_content_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void SynthesizeSpeechResponse::set_allocated_audio_content(::std::string* audio_content) {
  if (audio_content != NULL) {
    
  } else {
    
  }
  audio_content_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), audio_content,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:google.cloud.texttospeech.v1beta1.SynthesizeSpeechResponse.audio_content)
}
inline ::std::string* SynthesizeSpeechResponse::unsafe_arena_release_audio_content() {
  // @@protoc_insertion_point(field_unsafe_arena_release:google.cloud.texttospeech.v1beta1.SynthesizeSpeechResponse.audio_content)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return audio_content_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void SynthesizeSpeechResponse::unsafe_arena_set_allocated_audio_content(
    ::std::string* audio_content) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (audio_content != NULL) {
    
  } else {
    
  }
  audio_content_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      audio_content, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:google.cloud.texttospeech.v1beta1.SynthesizeSpeechResponse.audio_content)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1beta1
}  // namespace texttospeech
}  // namespace cloud
}  // namespace google

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::google::cloud::texttospeech::v1beta1::SsmlVoiceGender> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::texttospeech::v1beta1::SsmlVoiceGender>() {
  return ::google::cloud::texttospeech::v1beta1::SsmlVoiceGender_descriptor();
}
template <> struct is_proto_enum< ::google::cloud::texttospeech::v1beta1::AudioEncoding> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::texttospeech::v1beta1::AudioEncoding>() {
  return ::google::cloud::texttospeech::v1beta1::AudioEncoding_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_google_2fcloud_2ftexttospeech_2fv1beta1_2fcloud_5ftts_2eproto
